# 기본 문법 개우기

## 2.1 코드 작성 규칙
## 세미콜론 : 한문장의 끝을 의미
- 붙여도 되고 안붙여도 됨
- 가능한 붙이는 것을 권장
  
### 주석: comment
- 한줄 주석
  - Ctrl + /
  - //
- 여러줄 주석
  - Alt + Shift + A
  - /* ~~~ */

### 들여쓰기: indent
- tap size

## 2.2 자료형(Data Type)

### 기본 자료형(primitive Type)
- string
- number
- boolean
- undefined

### 객체 자료형: 사용자 정의 자료형(Object Type)
	: 배열형, null, 사용자 정의 객체(object)

### Symbol형

### 2.2.1 문자열
- 표현 : ' ' (따옴표), " " (쌍따옴표), ` `(백틱)
- 백틱(` `)은 내부에 ', ", 변수등을 사용할수 있다.
  - 템플릿 문자열
  - ` 개행(/n), ', ", 입력한 대로 문자열 처리
  - ` ${변수명} `
- 문자열 내에서 특수한 문자를 표시하기 위해
  - Escape Sequence(이스케이프 문자열)
  - \n
  - \t
  - \b
  - \'
  - \"
  - \\
- '\n'.length: 문장 1개 취급
- '', "", `` :빈문자열

- 문자열의 연결 (합치기)
  - \+ 연산자 사용
  - 문자열 + 숫자 : 숫자를 문자열 취급(형변환)

### 2.2.2 숫자
- 정수
  - 123
- 실수 (부동소수점)
  - 123.45
  - 1.2345e + 2

- 진법 표기 숫자
  - 10진수 : 일반적인 숫자표기
  - 2진수 : 0b + '0' 또는 '1'
  - 16진수 : 0x + '0~9A~F' , 0x + '0~9a~f'
  - 8진수 : 0o + '0~7'

- 문자열 --> 숫자 변경
  - parseInt(문자열[,기수])
    - parseInt('123일본'); parseInt('일본123'); parseInt('일123본')
  - parseFloat(문자열[,기수])
  - 반환값 = prompt(출력문자열), 반환값의 typeOf ----> string
- NaN : Not a Number 약자 숫자가 아님을 나타내는 자바스크립트 리터럴
- 리터럴 (literal) : 구체적인 값

- 산술 연산자
  - +, -, *. /, %
  - ** : 2 ** 4 : 2의 4승

- Infinity
  - 숫자를 0을 나눔

- 오해하기 쉬운 연산자
  - +
    - 산술 더하기
    - 문자열 연결하기 : 피연산자가 하나라도 문자열이면 문자열로 변경처리
    - 부호:단항 연산 +1, +200

  - -
    - 산술빼기
      - 문자열 - 숫자/ 숫자 - 문자열
    - 부호 : -200

  - *, /
  
### 연산자 우선순위 (operator priority)
  - () : 괄호가 제일 쎈놈
  - 같은 레벨의 연산자는 왼쪽이 더 우선순위가 높다고 판정
  - 예외 : 대입 연산자(=)는 오른쪽에 있는 것이 더 우선순위가 높다고 판정
  

### 2.2.3 불값(boolean)
  - true/false
  - 숫자로 취급하면 : 0/1
  - 비교연산의 결과/논리연산의 결과
  - false로 처리되는 경우
    - 0 undefined
    - null
    - NaN
    - '' : 빈물자열
  - true로 처리되는 경우
    - 상기 false의 경우를 제외한 경우

- NaN과 NaN 비교 -> false
- null과 null을 비교 -> true
- undefined 비교  -> true

- 문자열의 비교
  - 문자에 대한 값 : ASCII값(unicode)
  - 'a'.charCodeAt()

- ==와(과) ===
  - 동일한 점
    - 값을 비교
  - 차이나는 점
    - 테이터타입도 비교 여부
    - === : 타입 비교
- != 와(과) !==

- ===를 쓰는것이 바람직하다

### 비교 연산자
  - >, >=, <, <=, ==, ===, !=, !==
### 논리 연산자
  - && : AND
    - ~하고
    - a && b
      - a의 값과 b의 값인 true인 경우만 true 결과
  - || : OR
    - ~이거나
    - a || b
      - a의 값과 b의 값중 어느 하나라도 true인 경우만 true 결과
      - a의 값과 b의 값중에 모두 false인 경우만 false 결과
      - 엔터키입력? || 텝키입력?
  - ! : NOT
    - ~이지 않다
    - 남자가 아니다.
    - 100이 아니다.
      - a = 100
      - !a

## 단항 연산자는 오른쪽에서 왼쪽으로 실행 우선순위 결정

### 빈값 사용하기
- null
- undefined

- 공통점 : 값이 없다
  - falsy value 취급
  - undefined == false ===> ? false
  - null == false ===> ? false
  - null == 0 ===> ? false
- 차이점 :
  - 타입 : null:object == undefined:undefined

- JS : undefined를 기본값으로 취급, 빈값표현으로 undefined권장

## 2.3 변수
- 변수는 수, 프로그램 실행시 임시로 저장한 데이터 장소
- 관례 : 변수는 선언 및 초기화 후 사용하는 것 권장

### 1) 선언 (declaration)
- var
  - 특성
    - 같은 변수명으로 여러번 선언가능
- let
- const : 상수 (constant)
  -  변하지 않는 수
  -  const로 선언문을 사용할 경우 초기화 하지 않으면 에러
  -  const로 선언한 상수에 값 쓰기 금지
- let 변수명; // 선언문

* 변수명/상수명
  - $, _, 문자(유니코드로 가능), 숫자
  - 숫지로 시작할 수 없다.
  - JS의 키워드는 사용할 수 없다.

* 선언만 하면 변수는 undefined값


### 2) 초기화(initialization)
- 변수 선언시 값을 대입한 행위
- let 변수명 = 초기값;
  - 초기값 : 리터럴, 식 (expression)
### 3) 사용
####  3-1) 읽기
- 변수명

####  3-1) 쓰기
- 변수명에 대입연산

  
### 힙(heap) 스택(stack)
- 창고 : 메모리
- 상자 준비 : 변수 선언
- 상자 운영 : 변수명
- 상자 넣기 : 변수 대입

> 문, 식
>> 문(statement) : 선언문, 조건문, 반복문, 등의 문장, 해당하는 문장에 대한 실행
>> 식(expression) : 수식 등을 말하고, 실행 + 결과

## 2.4 조건문
### if문
- if(조건식){  
  문장1;  
  [문장2;  
  ...]  
}

### if문-else문
- if(조건식){  
  문장1;  
    [문장2;  
    ...]  
  }else{  
  문장1;[  
    문장2;  
    ...]  
}
### if문-else if-else문
- if(조건식1){  
  문장1;  
  [문장2;  
  ...]  
}else if(조건식2){  
  문장1;[  
    문장2;  
  ...]  
}else if(조건식3){  
  문장1;[  
    문장2;  
  ...]  
}else{  
  문장1;[  
    문장2;  
  ...]  
}  
- ex) if(변수명){...} === if(변수명 == true){...}

### 중첩 if : nested if
- 내포된 if
- if문 내에 if문을 작성한 경우
  - 바람직하지 않다.
  > 중첩 조건문 : nested condition statement
  >> 조건문 내부에 조건문이 존재하는 경우
### switch문
- switch(수식){  
  case 값1 :  //수식의 결과값 === 값1 true인 경우  
    문장 1;  
    [break;] //break를 만날때 까지  
  case 값2 :  
    문장 2;  
    [break;]  
    ...  
  default : //어떠한 Case에도 일치하지 않을 때  
    문장 n;   
  }     
  (if switch 상호변경 시험;?)
#### break문
- 반복문에서도 사용
  - block : { ~ } 형태의 코드
- 실행 block을 중단하는 문장
- 실행의 범위
  - break문이 속해 있느 block 하나만 중단
  - for() { for() { break } }
#### continue문
- 중단
- continue문을 실행되면 조건문 검사을 실행함

### 3항 연산자 : 조건부 연산자
- 조건식?참인경우실행할 문장/식 : 거짓인경우실행할 문장/식;

## 2.5 반복문
### while
- while(조건문){  
  실행문 1;  
  [실행문 2;   
  ...]}  
- 조건식이 만족하는 동안(true인 동안) 블록내의 문장 실행
  - 조건식을 만족시킬수 있는 문장; // (1)  
    while(조건식){  // (2)  
      문장들;  
      ...  
      맨 마지막 조건식의 값 변화에 영향을 끼치는 문장; // (3)  
    }  
### do while
- do{  
    문장들;  
    ...  
    맨마지막 조건식의 값 변화에 영향을 끼치는 문장  
  }while(조건식);  
### for
- for(초기식; 조건식; 변화식){  
    문장들;  
    ...  
  }  
- 초기식 : (1)  한번만 실행
- 조건식 : (2)  조건식 검사 >> 문장 실행
- 변화식 : (3)  문장이 다 끝나고 변화식 실행 >> 조건식 
  #### for in
  #### for of

### 중첩반복문 (nested loop)
- 반복문안에 반복문이 있는 경우
- 이중반복문, 삼중반복문, ...n

## 2.6 객체 (object)
- JS 데이터 타입의 일종
- 배열, 함수, 그외 정의해나가는 자료(객체)
###　배열(Array)
- 나열할 수 있는 데이터를 집합적으로 관리할 수 있은 데이터 타입
- 나열 가능한 데이터
  - 배열, 객체, 프리미티브타입, null, undefined, Infinity, NaN
- 데이터의 중복 가능, 순서 상관없음
- 요소 : element, 배열에 저장되는 하나의 데이터
- 인덱스(index) : 특정한 요소의 저장위치
#### 1) 선언/ 정의
- 대괄호 사용 : [요소1, 요소2, ...]
- Array() 상용 : Array객체의 생성자
  - new Array(숫자) : 빈 배열을 숫자만즘 생성
  - new Array(요소1, 요소2, ...)
- 배열내에 배열 요소가 저장되도록 한 것 : 다중 배열(다차원 배열), 2중 배열(2차원 배열)

#### 2) 사용
- 배열의 크기(길이) : 배열명.length
  - 맨 마지막 요소의 인덱스 : 배열명.length - 1
- 읽기
  - 배열명[인덱스]
- 쓰기
  - 배열명[인덱스] = 쓸값
- 수정
  - 배열명[인덱스] = 수정값
- 삭제 
  - delete 배열명[인덱스]
    - 해당요소 empty
- 맨 마지막에 추가
  - 배열명[배열명.length] = 추가값
  - 배열명.push(추가값)
- 맨 앞에 추가
  - 배열명,unshift(추가값)
- 맨 마지막에 삭제
  - 배열명.pop() : 삭제한 요소를 반환
- 맨앞 삭제
  - 배열멸.shift() : 삭제한 요소를 반환
- 수정과 삭제
  - 배열명.splice(시작index, 삭제요소 겟수.[, 추가할요소들])
  - 배열명.splice(시작index)
    - 식작index에서 배열 끝까지 삭제
  - 배열명.splice(시작index, 삭제요소갯수)
    - 식작index에서 지정한 갯수만큼 삭제
  - 배열명.splice(시작index, 삭제요소갯수, 추가할요소들)
    - 식작index에서 지정한 갯수만큼 삭제하고, 추가요소 삽입
- 검색
  - 배열명.includes(검색할요소)
    - 반환값 : boolean
  - 배열명.indexOf(검색할요소)
    - 반환값 : index값
    - 맨 처음부터 검색하여 검색성공한 최초의 인덱스
  - 배열명.lastIndexOf(검색할요소)
    - 반환값 : index값
    - 맨 마지막부터 검색하여 검색성공한 최초의 인덱스
    - 못찾으면 -1 반환
  - 반복
    - for문 사용
    - for-in문 사용
    - 배열명.forEach(함수)

### 함수(function)
- 특정한 작업을 수행하는 코드들의 집합
- 비유 : 자판기

#### 1) 정의/선언
- 선언문
  - function 함수명(파라미터리스트) { //함수의 시그니쳐, 함수의 헤더  
      // 중괄호 부분 : 함수의 바디  
    }
- 표현식 (expression) : 연산자 (=)
  - 이름 없는 선언문
    - const 상수명 = function(파라미터리스트) { ~ }; // 호출은 상수명(아규먼트 리스트)
  - 화살표 함수( arrow function)
    - const 상수명 = (파라미터리스트) => { ~ };
  - 이름 없는 선언문과 화살표 함수에서 사용하는 this는 다른 의미
#### 2) 호출
- 함수명 (아규먼트리스트) 
- 상수명 (아규먼트리스트)
- 호출하면 반드시 결과를 반환함
#### 3) 파라미터/ 아규먼트 : parameter, argument
- 파라미터 : 가인수
  - 함수선언시 함수 시그니쳐에 나오는 인수
- 아규먼트 : 실인수
  - 함수 호출시 사용하는 인수
#### 4) 반환
- return [데이터(변수, 리터럴)];
- return을 명시하지 않은 경우 return undefined; 맨마지막 샐행
  - 함수 내부에서 return문을 실행하는 경우 함수 실행 중지
  - 함수 호출한 곳의 그다음으로 실행순서 이동
#### 5) 함수내의 사용 변수 : scope
- 전역 변수 : 함수 내외부에서 사용가능
- 지역 변수 : 함수내에섬나 사용 가능
- 파라미터 : 지역변수 취급

#### 순수함수
- 파라미터와 지역변수/상수만으로 구현한 함수

### 함수선언과 화살표 함수 비교
- function add1(x, y){return x+y}
- const add2 = function(x, y) {return x + y;};
- const add3 = (x, y)=> {return x + y;};
- const add4 = (x, y)=>x + y;
  // 함수 실행문이 return만 존재하는 경우 중괄호 + return 생략가능
- const add5 = (x, y)=>(x + y);
- const not = x => !x; //파라미터가 하나인 경우 소괄호 생략가능 not(test)
- 주의사항 :this의 의미
- 화살표함수내에선 arguments를 사용 못함

### object literal
- 객체 : 어떤 특성을 가지는 대상에 대한 여러변수를 하나의 데이터로 묶은 것
#### 정의/선언/초기화
- const 객체명 = {    // 키1:값1, 키2:값2, 키3: 값3, ... 키n:값n  
    속성명1 : 속성값1,  // property(속성)  
    속성명2 : 속성값2,  
    속성명3 : 속성값3,  
    ...  
    속성명n : 속성값n,  
  }  
- 속성명 : 문자열로 지정
- 속성값 : 모든 data type들
- 속성값이 함수인 경우 : 매서드(method) : 객체내에 정의된 함수
  - console.log(문자열)

#### 사용법
- " . " 연산자 이용법
  - 객체명.속성명 : 읽기 
  - 객체명.속성명 = 값 : 쓰기/수정
  - 객체명.속성명(인수들)
- 연관배열이용법
  - 객체명['속성명']
    - 읽기 : 객체명['속성명']
    - 쓰기/수정 : 객체명['속성명'] = 값
  - 메서드 호출 불가
- 속성 삭제
  - delete 객체명.속성명;
  - delete 객체명['속성명'] ???


#### 연관배열
- Associated Array
- 연상배열??(일본어)
- 연관배열의 index : 문자열

#### 객체간 비교/참조/복사
- 비교
  - {} == {}, {} === {} ==> false
- 참조(reference)
  - 객체에 대한 변수는 해당 객체의 참조값을 저장
  - 참조값 : 메모리에서의 주소값 
  - primitive type의 변수 : 리터럴 값 저장
    - let a = 'jit';
    - 메모리(stack 메모리)에 값저장시키고 변수로 별명처럼 사용
- 객체의 복사
  - 단순 대입으로는 불가
  - const a = {}; const c = a;
    - 참조값의 복사로 a,c는 같은 객체를 참조하고 있음, 객체의 복사가 아님
    - clone()이용 복사해야 함

