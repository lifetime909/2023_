# 기본 문법 배우기

## 2.1 코드 작성 규칙
### 세미콜론 : 한문장의 끝을 의미
- 붙여도되고 안붙여도 됨
- 가능한 붙이는 것을 권장

### 주석: comment
- 한줄 주석
  - Ctrl+/
  - //
- 여러줄 주석
  - Alt+Shift+A
  - /* ~~~ */

### 들여쓰기: indent
- tab size

## 2.2 자료형(Data Type)

### 기본 자료형 (Primitive Type)
- string
- number
- boolean
- undefined

### 객체 자료형: 사용자 정의 자료형
    (Object Type)
    : 배열형, null, 사용자 정의 객체(object)

### Symbol형

### 2.2.1 문자열
- 표현: '' (따옴표), " "(쌍따옴표), ``(백틱)
- 백틱(``)은 내부에 ',", 변수등을 사용할 수 있다.
  - 템플릿 문자열
  - `  개행(\n), ' ,", 입력한 대로 문자열 처리  `
  - ` ${변수명} `
- 문자열 내에서 특수한 문자를 표시하기 위해
  Escape Sequence(이스케이프 문자열)
  \n
  \t
  \b
  \'
  \"
  \\
- '\n'.length: 문자 1개로 취급
- '', "", `` : 빈문자열

- 문자열의 연결 (합치기)
  - + 연산자 사용
  - 문자열+숫자: 숫자를 문자열 취급(형변환)

### 2.2.2 숫자
- 정수
  - 123
- 실수 (부동소수점)
  - 123.45
  - 1.2345e+2: 지수표기법

- 진법 표기 숫자
  - 10진수: 일반적인 숫자표기
  - 2진수: 0b + '0' 또는 '1'
  - 16진수: 0X + '0~9A~F' , 0x + '0~9a~f'
  - 8진수: 0o + '0~7'

- 문자열--> 숫자 변경
  - parseInt(문자열[,기수]): 기수- 표시 진법에 대한 숫자 - 16, 8 
    - parseInt('123일본'); parseInt('일본123'); parseInt('일123본');
  - parseFloat(문자열[,기수])
  - 반환값 = prompt(출력문자열), 반환값의 typeOf ---> string 
  - string의 첫 글자를 정수로 변경할 수 없으면 NaN(Not a Number) 값을 리턴합니다.
- NaN: Not a Number 약자 숫자가 아님을 나타내는 자바스크립트 리터럴
- 리터럴 (literal): 구체적인 값
  
- 산술 연산자
  - +, -, *, /, %  
  - ** : 2 ** 4 : 2의 4승 

- Infinity
  - 숫자를 0로 나눔

- 오해하기 쉬운 연산자
  - +
    - 산술 더하기: 피연산자가 숫자인 경우
    - 문자열 연결하기: 피연산자가 하나라도 문자열이면 문자열로 변경처리
    - 부호: 단항(피연산자가 하나) 연산 +1, +200
  - - 
    - 산술 빼기
      - 문자열 - 숫자 / 숫자 - 문자열
    - 부호: -100
  - *, /
  
  #### 연산자 우선순위 (operator priority)
  - (): 괄호가 제일 쎈놈
  - 같은 레벨의 연산자는 왼쪽이 더 우선순위가 높다고 판정
  - 예외: 대입연산자(=)는 오른쪽에 있는 것이 더 우선순위가 높다고 판정


### 2.2.3 불값(boolean)
- true/false
- 숫자로 취급하면: 1/0
- 비교연산의 결과/논리연산의 결과
- false로 처리되는 경우
  - 0
  - undefined
  - null
  - NaN
  - '' : 빈문자열
- true로 처리되는 경우
  - 상기 false의 경우 제외한 경우

- NaN과 NaN 비교: 이것만 false
- null과 null비교
- undefined 비교

- 문자열의 비교
  - 문자에 대한 값: ascii값(unicode)
  - 'a'.charCodeAt() 반화값 : ascii

- "=="와 "==="
  - 동일한점
    - 값을 비교
  - 차이나는점
    - 데이터타입도 비교 여부
      - === 타입을 비교한다.
- !=와 !==   

#### 비교 연산자
  - >, <, >=, <=, ==, ===, !=, !==
  
#### 논리 연산자
  - &&: AND
    - ~하고
    - a && b 
      - a의 값과 b의 값이 true인 경우만  true 결과 
  - ||: OR
    - ~이거나
    - a || b 
      - a의 값과 b의 값중 어느하나라도 true인 경우 true 결과
      - a의 값과 b의 값이 모두 false인 경우만 false 결과
      - 엔터키입력? || 텝키입력? 
  - !: Not
    - ~이지않다
    - 남자가 아니다.
    - 100이지 않다
      - a=100
      - !a

## 단항 연산자는 오른쪽에서 왼쪽으로 실행 우선순위 결정

### 빈값 사용하기
- null
- undefined

- 공통점: 값이 없다
  - falsy value 취급
  - undefined == false ===> ? 결과 false
  - null == false
  - null == 0
- 차이점: 
  - 타입: null:object == undefined:undefined 

- JS : undefined를 기본값으로 취급, 빈값표현은 undefined권장
  

## 2.3 변수 (Variables)
- 변하는 수, 프로그램 실행시 임시로 저장하는 데이터 장소
- 관례: 변수는 선언 및 초기화 후 사용하는 것 권장

### 1) 선언 (declaration)
- var
  - 특성
    - 같은 변수명으로 여러번 선언가능
- let
  - var의 문재점 개선
- const : 상수 (constant)
  - 변하지 않는 수
  - const로 선언문을 사용할 경우 초기화 하지 않으면 에러
  - const로 선언한 상수에 값 쓰기 금지  
- let 변수명; // 선언문

* 변수명/상수명
  - $, _, 문자(유니코드로 가능), 숫자
  - 숫자로 시작할 수 없다.
  - JS의 키워드는 사용할 수 없다.
  
* 선언만하면 변수는 undefined값

### 2) 초기화 (initialization)
- 변수 선언시 값을 대입하는 행위
- let 변수명=초기값;
  - 초기값: 리터럴, 식 (expression)

### 3) 사용
#### 3-1) 읽기
- 변수명
  
#### 3-2) 쓰기
- 변수명에 대입연산

> 문, 식
>> 문(statement): 선언문,조건문, 반복문 등의 문장, 해당하는 문장에 대한 실행
>> 식(expression): 수식 등을 말하고, 실행+결과

## 2.4 조건문
### if문
- if(조건식){
    문장1;
    [문장2;
    ...]
  }

### "if"~"else"문
- if(조건식){
    문장1;
    [문장2;
    ...]
  }else{
    문장e1;
    [문장e2;
    ...]
  }

### "if"~"else if"~"else"문
- if(조건식1){
    문장1;
    [문장2;
    ...]
  }else if(조건식2){
    문장e1;
    [문장e2;
    ...]
  } else if (조건식3){
     ...
  }...
  else{
    문장le1;
    [문장le2;
    ...]
  }

### 중첩 if: nested if 
- 내포된 if
- if문내에 if문을 작성한 경우
  - 바람직하지 않다.

### switch문
- switch(수식){
    case 값1:  // 수식의결과값===값1 true인 경우
      문장들1;
      [break;] // break를 만날때까지 실행
    case 값2:
      문장들2;
      [break;]
      ...
    default:
      문장들n; 
      [break;]  
  }
  

#### break문 
- 반복문에서도 사용
  - block: { ~ } 형태의 코드
- 실행 block 중단하는 문장
- 실행의 범위
  - break문이 속해 있는 block 하나만 중단
  - for(){ for(){ break } }
#### continue문 
- 중단
- continue문이 실행되면 조건문 검사를 실행함

### 3항 연산자: 조건부연산자
- 조건식?참인경우실행할문장/식:거짓인경우실행할문장/식  

## 2.5 반복문
### while
- while(조건식){
    실행문1;
    [실행문2;
    ...]
  }
- 조건식이 만족하는동안(true인동안) 블록내의 문장 실행
  - 조건식을만족시킬수있는문장;  // (1)
    while(조건식){    // (2)
       문장들; 
       ...
       맨마지막 조건식의 값 변화에 영향을 끼치는 문장;  // (3)
    }
### do while
- do{
    문장들; 
       ...
    맨마지막 조건식의 값 변화에 영향을 끼치는 문장;
  }while(조건식);
### for
- for(초기식;조건식;변화식){
    문장들; 
    ...
  }
- 초기식: (1)
- 조건식: (2)
- 변화식: (3)
  #### for in
  #### for of
  - 배열의 반복

### 중첩반복문 (nested loop)
- 반복문안에 반복문이 있는 경우
- 이중반복문, 삼중반복문, ... 

## 2.6 객체 (object)
- JS 데이터타입의 일종
- 배열, 함수, 그외 정의해나가는 자료(객체)
### 배열(array)
- 나열할 수 있는 데이터를 집합적으로 관리할 수 있는 데이터 타입
- 나열가능한 데이터
  - 배열, 객체, 프리미티브타입, null, undefined, Infinity, NaN
- 데이터의 중복 가능, 순서 상관없음
- 요소: element, 배열에 저장되는 하나의 데이터
- 인덱스(index): 특정한 요소의 저장위치

  
#### 1) 선언/정의
- 대괄호 사용: [요소1, 요소2,...] 
- Array() 사용: Array객체의 생성자
  - new Array(숫자) : 빈 배열을 숫자만큼 생성
  - new Array(요소1, 요소2, ...)
- 배열내에 배열요소가 저장되도록 한 것: 다중배열(다차원배열), 2중배열(이차원배열)

#### 2) 사용
- 배열의 크기(길이): 배열명.length
  - 맨마지막요소의 인덱스: 배열명.length-1
- 읽기
  - 배열명[인덱스]
- 쓰기
  - 배열명[인덱스] = 쓸값
- 수정
  - 배열명[인덱스] = 수정값
- 삭제
  - delete 배열명[인덱스]
    - 해당요소 empty
- 맨마지막에 추가
  - 배열명[배열명.length] = 추가값
  - 배열명.push(추가값)
- 맨앞에 추가
  - 배열명.unshift(추가값)
- 맨마지막에 삭제
  - 배열명.pop(): 삭제한 요소를 반환
- 맨앞에 삭제
  - 배열명.shift(): 삭제한 요소를 반환
- 삽입과 삭제
  - 배열명.splice(시작index[, 삭제요소갯수[, 추가할요소들]])
  - 배열명.splice(시작index)
    - 시작index에서 배열끝까지 삭제
  - 배열명.splice(시작index, 삭제요소갯수)
    - 시작index에서 지정한 갯수만큼 삭제
  - 배열명.splice(시작index, 삭제요소갯수, 추가할요소들)
    - 시작index에서 지정한 갯수만큼 삭제하고, 추가요소 삽입
- 검색
  - 배열명.includes(검색할요소)
    - 반환값: boolean
  - 배열명.indexOf(검색할요소)
    - 반환값: index값
    - 맨처음부터 검색하여 검색성공한 최초의 인덱스
    - 못찾으면 -1 반환
  - 배열명.lastIndexOf(검색할요소)
    - 반환값: index값
    - 맨마지막부터 검색하여 검색성공한 최초의 인덱스
    - 못찾으면 -1 반환
- 반복
  - for문사용
  - for~in문사용
  - 배열명.forEach(함수)


### 함수(function)
- 특정한 작업을 수행하는 코드들의 집합
- 비유: 자판기

#### 1) 정의/선언
- 선언문
  - function 함수명(파라미터리스트){  // 함수의 시그니쳐, 함수의 헤더
      // 중괄호 부분: 함수의 바디
    }
- 표현식 (expression): 연산자(=)
  - 이름없는 선언문
    - const 상수명 = function(파라미터리스트){}; // 호출: 상수명(아규먼트리스트)
  - 화살표함수(arrow function)
    - const 상수명 = (파라미터리스트)=>{};

#### 2) 호출
- 함수명(아규먼트리스트)
- 상수명(아규먼트리스트)
- 호출하면 반드시 결과를 반환함

#### 3) 파라미터/아규먼트: parameter, argument
- 파라미터 : 가인수
  - 함수선언시 함수 시그니쳐에 나오는 인수
- 아규먼트 : 실인수
  - 함수 호출시 사용하는 인수
#### 4) 반환
- return [데이터(변수, 리터널)];
- return을 명시하지 않은 경우 return undefined; 맨마지막 실행
  - 함수 내부에서 return문을 실행하는 경우 함수 실행 중지
  - 함수 호출한 곳의 그다음으로 실행순서 이동
#### 5) 함수내의 사용 변수: scope
- 전역변수: 함수내외부에서 사용가능
- 지역변수: 함수내에서만 사용 가능
- 파라미터: 지역변수 취급

#### 순수함수
- 파라미터와 지역변수/상수만으로 구현한 함수

### 함수선언과 화살표함수 비교
- function add1(x,y){ return x+y;} 
- const add2 = function(x,y){ return x+y;};
- const add3 = (x,y)=>{ return x+y;};
- const add4 = (x,y)=> x+y; 
  // 함수 실행문이 return만 존재하는 경우 중괄호+return 생략가능
- const add4 = (x,y)=> (x+y);
- const not = x => !x;  // 파라미터가 하나인 경우 소괄호 생략가능 not(test)
- 주의사항: this의 의미
- 주의사항: 화살표함수내에선 arguments를 사용 못함


### object literal
- 객체: 어떤 특성을 가지는 대상에 대한 여러변수를 하나의 데이터로 묶은 것
  
#### 정의/선언/초기화
- const 객체명 = {   // 키1:값1, 키2:값2,..., 키n:값n
    속성명1:속성값1, // property(속성)
    속성명2:속성값2,
    ...
    속성명n:속성값n[,]
  }
- 속성명: 문자열로 지정
- 속성값: 모든 data type들
- 속성값이 함수인 경우: 메서드(method): 객체내에 정의된 함수
  - console.log(문자열)

#### 사용법
- . 연산자 이용법
  - 객체명.속성명 : 읽기
  - 객체명.속성명 = 값: 쓰기/수정
  - 객체명.속성명(인수들)
- 연관배열이용법
  - 객체명['속성명']
    - 읽기: 객체명['속성명']
    - 쓰기/수정: 객체명['속성명'] = 값
  - 메소드 호출 불가
- 속성 삭제
  - delete 객체명.속성명;
  - delete 객체명['속성명'] ???

#### 연관배열
- Associated Array
- 연상배열??
- 연관배열의 index: 문자열

#### 객체간 비교/참조/복사
- 비교
  - {} == {}, {} === {} ==> false
- 참조(reference)  
  - 객체에 대한 변수는 해당 객체의 참조값을 저장
  - 참조값: 메모리(heap 메모리)에서의 주소값 
  - primitive type의 변수: 리터럴 값 저장
    - let a = 'jit';
    - 메모리(stack 메모리)에 값저장시키고 변수로 별명처럼 사용
- 객체의 복사
  - 단순 대입으로는 불가
  - const a = {}; const c =a; 
    - 참조값의 복사로 a,c는 같은 객체를 참조하고 있음, 객체의 복사가 아님
    - clone()이용 복사해야 함
